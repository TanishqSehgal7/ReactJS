Initialize repository and push to github through 
commands:

1. Make readme file

echo "ReactJS" >> ReadMe.md

2. Initialize git repository

git init

3. Add ReadMe file to github repository
git add README.md

4. Commit to git with message
git commit -m "first-commit"

5. Make a branch on git
git branch -M main

6. Add origin branch to remote
git remote add origin 
https://github.com/TanishqSehgal7/ReactJS.git

7. Push branch to origin
git push -u origin main

===========================================================

package-lock.json file, some information..
Here it is : 

1. Dependency Version Locking: Locks exact versions.
2. Specific Version Recording: Records exact nested dependency 
versions.
3. Dependency Resolution: Ensures consistent installs.
4. Consistency & Reproducibility: Same versions for all.
5. Avoid Manual Editing: Risk of conflicts.

In a nutshell, `package-lock.json` lists and locks 
down specific versions of all project dependencies, 
ensuring consistent installations and preventing 
version conflicts. It's hands-off for manual edits to 
avoid potential issues.

===========================================================

ReactDOM/Virtual DOM - react creates its own DOM 
and compares it to the actual browser dom and
updates only those elements which need an updation
or any change.

ReactDOM.createRoot(document.getElementById('root'))
.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)

In virtual DOM there is a method called 
createRoot() which creates a root element which
will be the outermost container for the HTML
webpage.

root.render() -> this renders the React App. Using
jsx, we can render html elements into a webpage
using javascript.


function App() {
  const [count, setCount] = useState(0)
  return (
    <>
      <h1>Hello World!!</h1>
      <p className="read-the-docs">
        This is my first React Project
      </p>
    </>
  )
}

export default App

App is a function which return HTML elements that 
are to be rendered inside the root element.

In vite, react script is directly loaded inside
the html page using the script tag just like the 
standard way of loading a basic javascript file.

In order to return multiple components inside the react app,
we need to wrap them up inside an empty tag called
fragment <></>
Without a fragment only one element/component can be 
rendered.

IN a react app which is made using Vite, the javascript
files should always have the extension as .jsx
.js files would throw an error.

While making components, always keep the component name
starting with capital letters which prevents errors
be it in Vite project or be it npx create-react-app
project.


function App() {
  const userName = "Tanishq";
  return (
    <>
      <h1>Hello World!!</h1>
      <p className="read-the-docs">
        This is my first React Project with username {username}
      </p>
    </>
  )
}

{username} ->  this is the way we can inject javascript inside the
returned HTML content. But this only takes up the evaluated 
expression, ie, no code logic/changes can be done here. Rather,
it only accepts the evaluated values/variables etc.

React.createElement() is automatically injected by Babel
which is a transpiler toolchain that is mainly used to 
convert ECMAScript 2015+ code into a backwards compatible 
version of JavaScript in current and older browsers 
or environments.

React controls all the UI updation of the app for which we
need React Hooks which help us make the updated values of 
different variables visible to the UI.

====================================================================

createRoot() method -> this creates a DOM like structure exactly like
the browser. It compares the maine DOM and the DOM created itself, the
(Virtual DOM) and only updates the elements which have some updation
or changes. While browser DOM re-builds the entire DOM again and re-paints
it on the webpage. This is called page reload.

React uses Fiber algorithm behind the scene to update the Virtual DOM
The goal of React Fiber is to increase it suitability for areas like 
animation, layout, and gestures. Its main feature is incremental UI 
rendering. When UI is being updated through some network calls or when
UI is getting simultaneous updates at a time, then it has to be updated
multiple times till the last update is populated. So to optimize this,
React Fiber algorithm was implemented.

It splits rendering into multiple chunks and spread it out over multiple
frames. It can also pause, abort or reuse work as new updation, 
assign priority to different types of updates.

Reconcillation - its is a react algorithm which re-considers what
to be updated in the UI and what not to be updated. This basically 
compares React Tree structure (Virtual DOm) and browser DOM and 
updates UI accordingly.

An update is a change in the data used to render a React app. It is
usually the result of "setState" and eventually results in a 
re-render.

When you render a React App, a tree of nodes that describes the app
is generated and saved in the memory. This tree is flushed into the
rendering environment. When the app is updated, a new tree is generated
and the new tree is diffed with the previous tree to compute which
operations are neeed to update the rendered app.

Diffing Algorithm High Level Description:
=> Different component types are assumed to generate substantially
different trees. React will not attempt to diff them but rather 
replace the old tree completely.
=> Diffing of lists is performed using keys, Keys should be stable,
predictable, and unique.

In a UI, it is not necessary for every update to be applied immediately
In fact, doing so can be wasteful, causing frames to drop and 
degrading the user experience.

Different updates have different priorities, like an animation 
update needs to complete more quickly than, say, an update from a 
data store.

Push based approach -> requires app (programmer) to decide how 
to schedule work. 

Pull based approach -> allows the framework (React) to be smart and
make those decisions for you.

PRIMARY GOAL OF FIBER IS TO ENABLE REACT TO TAKE ADVANTAGE OF 
THE SCHEDULING. Specifically we need to be able to:
1. Pause work and come back to it later.
2. Assign priority to different types of work.
3. Reuse previously completed work.
4. Abort work if it is no longer needed.

===========================================================================

Props in React -> props makes the same component re-usable for different
scenarios and is written only once as a separate component.
 
